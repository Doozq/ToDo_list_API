# ToDo_list_API

Этот проект представляет собой REST API для управления списком задач (ToDo List). API позволяет создавать, обновлять, удалять задачи и работать с комментариями, файлами и статусами задач. Для разработки использовались Django и Django REST Framework. База данных PostgreSQL.

## Выполненные задания

Все

## Установка и настройка

### 1. Клонирование репозитория

Сначала клонируйте репозиторий:

```bash
git clone https://github.com/Doozq/ToDo_list_API.git
cd ToDo_list_API
```

### 2. Создание виртуального окружения

Для создания изолированного виртуального окружения рекомендуется использовать `venv`:

```bash
python -m venv venv
```

Активируйте виртуальное окружение:

- Для Windows:
  ```bash
  venv\Scripts\activate
  ```

- Для Mac/Linux:
  ```bash
  source venv/bin/activate
  ```

### 3. Установка зависимостей

Установите все необходимые зависимости, указанные в `requirements.txt`:

```bash
pip install -r requirements.txt
```

### 4. Настройка базы данных

Приложение использует PostgreSQL, поэтому необходимо создать базу данных. В файле `settings.py` убедитесь, что конфигурация базы данных настроена правильно, предварительно создав базу данных postgres.

Пример конфигурации PostgreSQL:

```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': '{имя вашей базы данных}',
        'USER': '{ваш user}',
        'PASSWORD': '{ваш пароль}',
        'HOST': 'localhost',
        'PORT': '5432',
    }
}
```

После того как база данных настроена, выполните миграции:

```bash
cd todo
python manage.py migrate
```

### 5. Создание суперпользователя

Для доступа к административной панели Django создайте суперпользователя:

```bash
python manage.py createsuperuser
```

Введите имя пользователя, email и пароль, когда будет предложено.

### 6. Запуск сервера

Запустите сервер разработки:

```bash
python manage.py runserver
```

По умолчанию сервер будет доступен по адресу: `http://127.0.0.1:8000/api/`.

### 7. Получение JWT токена

Для выполнения защищенных запросов через API, вам нужно получить токен. Для этого выполните POST запрос к следующему эндпоинту:

```bash
POST /api/token/
```

Примеры запроса для получения токена:

```bash
curl -X POST -H "Content-Type: application/json" -d '{"username": "your_username", "password": "your_password"}' http://127.0.0.1:8000/api/token/
```
или
```bash
Invoke-WebRequest -Uri http://127.0.0.1:8000/api/token/ -Method Post -Headers @{"Content-Type"="application/json"} -Body '{"username": "your_username", "password": "your_password"}'
```
или же просо можете перейти в браузере по адрессу `http://127.0.0.1:8000/api/token/`

Ответ будет содержать `access` и `refresh` токены:

```json
{
    "access": "your_access_token",
    "refresh": "your_refresh_token"
}
```
access token действителен 1 час


### 8. Использование токена

Для доступа к защищенным эндпоинтам (например, для создания задач, получения задач, добавления комментариев и т.д.), необходимо передавать `access` токен в заголовке `Authorization`:

Пример запроса с токеном:

```bash
curl -X GET -H "Authorization: Bearer your_access_token" http://127.0.0.1:8000/api/tasks/
```

### 9. Документация API

Документация доступна по адресу:

```
http://127.0.0.1:8000/api/docs/
```

### 10. Запуск тестов

Чтобы выполнить тесты проекта, используйте команду:

```bash
python manage.py test
```

## Трудности
- При выполнении задания, возникли трудности с авторизацией, но они были решены с помощью докментации simple-jwt
- Сложнее всего было добавление коментариев, сначала не понимал как это правильно реализовать, потом решил сделать через ArrayField для модели Task, но столкнулся с проблемой что при добавлении новых коментариев к задаче, старые удаляются. Поэтому я решил что правильным решением будет создание отдельной модели для комментария, но и с этим возникли трудности: отображение комментариев для конкртеной задачи, автоматическое указание задачи при создании коментария - все были решены.
- Остальные проблемы не вызывали трудностей и решались с помощью документации drf и открытых источников информации, для тестов и readme использовалась помощь gpt.
